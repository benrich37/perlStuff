import os
from ase.io import read, write
from ase.io.trajectory import Trajectory
from ase.optimize import FIRE
from os.path import join as opj
from os.path import exists as ope
import numpy as np
import shutil
from ase.neb import NEB
import time
from scripts.out_to_logx import get_do_cell
from helpers.generic_helpers import get_int_dirs, copy_state_files, atom_str, get_cmds, get_int_dirs_indices
from helpers.generic_helpers import fix_work_dir, read_pbc_val, get_inputs_list, _write_contcar, add_bond_constraints, optimizer
from helpers.generic_helpers import dump_template_input, _get_calc, get_exe_cmd, get_log_fn, copy_file, log_def
from helpers.generic_helpers import _write_logx, _write_opt_log, check_for_restart, finished_logx, sp_logx, bond_str
from helpers.generic_helpers import remove_dir_recursive
from helpers.se_neb_helpers import get_fs, has_max, check_poscar, neb_optimizer, log_total_elapsed

se_neb_template = ["k: 0.1 # Spring constant for band forces in NEB step",
                   "neb method: spline # idk, something about how forces are projected out / imposed",
                   "scan: 3, 5, 10, 0.23 # (1st atom index (numbering from 0), 2nd atom index, number of steps, step size)",
                   "restart: 3 # step number to resume (if not given, this will be found automatically)",
                   "# restart: neb # would trigger a restart for the neb if scan has been completed"
                   "max_steps: 100 # max number of steps for scan opts",
                   "neb max steps: 30 # max number of steps for neb opt",
                   "fmax: 0.05 # fmax perameter for both neb and scan opt",
                   "follow: False # Request true for guess structure of new scan structures to be generated by velocity"
    + " following previous two structures",
                   "pbc: True, true, false # which lattice vectors to impose periodic boundary conditions on",
                   "relax: start, end # start optimizes given structure without frozen bond before scanning bond, end "
                   + "optimizes final structure without frozen bond"]

def read_se_neb_inputs(fname="se_neb_inputs"):
    if not ope(fname):
        dump_template_input(fname, se_neb_template, os.getcwd())
        raise ValueError(f"No se neb input supplied: dumping template {fname}")
    k = 1.0
    neb_method = "spline"
    interp_method = "linear"
    lookline = None
    restart_idx = None
    restart_neb = False
    max_steps = 100
    neb_max_steps = None
    fmax = 0.01
    work_dir = None
    follow = False
    debug = False
    relax_start = True
    relax_end = True
    inputs = get_inputs_list(fname)
    pbc = [True, True, False]
    for input in inputs:
        key, val = input[0], input[1]
        if "scan" in key:
            lookline = val.split(",")
        if "restart" in key:
            if "neb" in val:
                restart_neb = True
            else:
                restart_idx = int(val.strip())
        if "debug" in key:
            restart_bool_str = val
            debug = "true" in restart_bool_str.lower()
        if "work" in key:
            work_dir = val.strip()
        if ("method" in key) and ("neb" in key):
            neb_method = val.strip()
        if ("method" in key) and ("interp" in key):
            interp_method = val.strip()
        if "follow" in key:
            follow = "true" in val
        if key.lower()[0] == "k":
            k = float(val.strip())
        if "fix" in key:
            lsplit = val.split(",")
            fix_pairs = []
            for atom in lsplit:
                try:
                    fix_pairs.append(int(atom))
                except ValueError:
                    pass
        if "max" in key:
            if "steps" in key:
                if "neb" in key:
                    neb_max_steps = int(val.strip())
                else:
                    max_steps = int(val.strip())
            elif ("force" in key) or ("fmax" in key):
                fmax = float(val.strip())
        if "pbc" in key:
            pbc = read_pbc_val(val)
        if "relax" in key:
            if "start" in val:
                relax_start = True
            if "end" in val:
                relax_end = True
    atom_pair = [int(lookline[0]), int(lookline[1])]
    scan_steps = int(lookline[2])
    step_length = float(lookline[3])
    if restart_neb:
        restart_idx = scan_steps + 1
    if neb_max_steps is None:
        neb_max_steps = int(max_steps / 10.)
    work_dir = fix_work_dir(work_dir)
    return atom_pair, scan_steps, step_length, restart_idx, work_dir, follow, debug, max_steps, fmax, neb_method,\
        interp_method, k, neb_max_steps, pbc, relax_start, relax_end


def get_atoms_prep_follow(atoms, prev_2_out, atom_pair, target_length):
    atoms_prev = read(prev_2_out, format="vasp")
    dir_vecs = []
    for i in range(len(atoms.positions)):
        dir_vecs.append(atoms.positions[i] - atoms_prev.positions[i])
    for i in range(len(dir_vecs)):
        atoms.positions[i] += dir_vecs[i]
    dir_vec = atoms.positions[atom_pair[1]] - atoms.positions[atom_pair[0]]
    cur_length = np.linalg.norm(dir_vec)
    should_be_0 = target_length - cur_length
    if not np.isclose(should_be_0, 0.0):
        atoms.positions[atom_pair[1]] += dir_vec * (should_be_0) / np.linalg.norm(dir_vec)
    return atoms


def _prep_input(step_idx, atom_pair, step_length, start_length, follow, step_dir, scan_dir, log_func=log_def, step_type=1):
    step_prev_1_dir = opj(scan_dir, str(step_idx-1))
    step_prev_2_dir = opj(scan_dir, str(step_idx - 2))
    prev_1_out = opj(step_prev_1_dir, "CONTCAR")
    prev_2_out = opj(step_prev_2_dir, "CONTCAR")
    print_str = f"Prepared structure for step {step_idx} with"
    target_length = start_length + (step_idx*step_length)
    atoms = read(prev_1_out, format="vasp")
    if step_idx <= 1:
        follow = False
    if follow:
        print_str += " atom momentum followed"
        atoms = get_atoms_prep_follow(atoms, prev_2_out, atom_pair, target_length)
    else:
        dir_vec = atoms.positions[atom_pair[1]] - atoms.positions[atom_pair[0]]
        dir_vec *= step_length / np.linalg.norm(dir_vec)
        if step_type == 0:
            print_str += f" only {atom_str(atoms, atom_pair[1])} moved"
            atoms.positions[atom_pair[1]] += dir_vec
        elif step_type == 1:
            print_str += f" only {atom_str(atoms, atom_pair[0])} and {atom_str(atoms, atom_pair[1])} moved equidistantly"
            dir_vec *= 0.5
            atoms.positions[atom_pair[1]] += dir_vec
            atoms.positions[atom_pair[0]] += (-1) * dir_vec
        elif step_type == 2:
            print_str += f" only {atom_str(atoms, atom_pair[0])} moved"
            atoms.positions[atom_pair[0]] += (-1) * dir_vec
    write(opj(step_dir, "POSCAR"), atoms, format="vasp")
    log_func(print_str)



def get_start_dist(scan_dir, atom_pair, restart=False, log_fn=log_def):
    dir0 = opj(scan_dir, "0")
    atoms = get_atoms(dir0, [False,False,False], restart=restart, log_fn=log_fn)
    dir_vec = atoms.positions[atom_pair[1]] - atoms.positions[atom_pair[0]]
    start_dist = np.linalg.norm(dir_vec)
    log_fn(f"Bond {bond_str(atoms, atom_pair[0], atom_pair[1])} starting at {start_dist}")
    return start_dist


def do_relax_start(relax_start_bool, scan_dir, get_calc_fn, log_fn=log_def, fmax=0.05, max_steps=100):
    if relax_start_bool:
        dir0 = opj(scan_dir, "0")
        se_log(f"Relaxing initial geometry in {dir0}")
        atoms = get_atoms(dir0, pbc, restart=True, log_fn=log_fn)
        run_relax_opt(atoms, dir0, FIRE, get_calc_fn, fmax=fmax, max_steps=max_steps, log_fn=log_fn)

def do_relax_end(scan_steps, scan_dir, restart_idx, pbc, get_calc_fn, log_fn=log_def, fmax=0.05, max_steps=100):
    end_idx = scan_steps
    end_dir = opj(scan_dir, str(end_idx))
    prev_dir = opj(scan_dir, str(end_idx - 1))
    if (not ope(opj(end_dir, "POSCAR"))) or (not os.path.isdir(end_dir)):
        os.mkdir(end_dir)
        restart_end = False
        copy_state_files(prev_dir, end_dir, log_fn=log_fn)
        prep_input(scan_steps, end_dir)
    else:
        restart_end = (end_idx == restart_idx) and (not is_done(end_dir, end_idx))
    atoms = get_atoms(end_dir, pbc, restart=restart_end, log_fn=se_log)
    run_relax_opt(atoms, end_dir, FIRE, get_calc_fn, fmax=fmax, max_steps=max_steps, log_fn=log_fn)



def finished(front_dir):
    with open(opj(front_dir, f"finished_{os.path.basename(front_dir)}.txt"), "w") as f:
        f.write("done")

def is_done(dir, idx):
    return ope(opj(dir, f"finished_{idx}.txt"))

def get_restart_idx(restart_idx, scan_dir):
    if not restart_idx is None:
        return restart_idx
    else:
        restart_idx = 0
        if not ope(scan_dir):
            return restart_idx
        else:
            int_dirs = get_int_dirs(scan_dir)
            int_dirs_indices = get_int_dirs_indices(int_dirs)
            for i in range(len(int_dirs)):
                look_dir = int_dirs[int_dirs_indices[i]]
                if is_done(look_dir, i):
                    restart_idx = i
                else:
                    return restart_idx

def get_atoms(dirr, pbc, restart=False, log_fn=log_def):
    _abort = False
    POSCAR = opj(dirr, "POSCAR")
    CONTCAR = opj(dirr, "CONTCAR")
    if restart:
        if ope(CONTCAR):
            atoms = read(CONTCAR, format="vasp")
            log_fn(f"Found CONTCAR in {dirr}")
        elif ope(POSCAR):
            atoms = read(POSCAR, format="vasp")
            log_fn(f"Could not find CONTCAR in {dirr} - using POSCAR instead")
        else:
            _abort = True
    else:
        if ope(POSCAR):
            atoms = read(POSCAR, format="vasp")
            log_fn(f"Found CONTCAR in {dirr}")
        elif ope(CONTCAR):
            atoms = read(CONTCAR, format="vasp")
            log_fn(f"Could not find start POSCAR in {dirr} - using found CONTCAR instead")
        else:
            _abort = True
    if _abort:
        log_fn(f"Could not find structure from {dirr} - aborting")
        assert False
    atoms.pbc = pbc
    log_fn(f"Setting pbc for atoms to {pbc}")
    return atoms

def run_opt_runner(atoms, root, opter, log_fn = log_def, fmax=0.05, max_steps=100):
    dyn = optimizer(atoms, root, opter)
    traj = Trajectory(opj(root, "opt.traj"), 'w', atoms, properties=['energy', 'forces', 'charges'])
    logx = opj(root, "opt.logx")
    do_cell = get_do_cell(atoms.pbc)
    write_logx = lambda: _write_logx(atoms, logx, dyn, max_steps, do_cell=do_cell)
    write_contcar = lambda: _write_contcar(atoms, root)
    write_opt_log = lambda: _write_opt_log(atoms, dyn, max_steps, log_fn)
    dyn.attach(traj.write, interval=1)
    dyn.attach(write_contcar, interval=1)
    dyn.attach(write_logx, interval=1)
    dyn.attach(write_opt_log, interval=1)
    log_fn("Optimization starting")
    log_fn(f"Fmax: {fmax}, max_steps: {max_steps}")
    dyn.run(fmax=fmax, steps=max_steps)
    log_fn(f"Finished in {dyn.nsteps}/{max_steps}")
    finished_logx(atoms, logx, dyn.nsteps, max_steps)
    sp_logx(atoms, "sp.logx", do_cell=do_cell)
    finished(root)

def run_relax_opt(atoms, opt_dir, opter, get_calc_fn,
                  fmax=0.05, max_steps=100, log_fn=log_def, _failed_before=False):
    atoms.set_calculator(get_calc_fn(opt_dir))
    run_again = False
    try:
        run_opt_runner(atoms, opt_dir, opter, fmax=fmax, max_steps=max_steps, log_fn=log_fn)
    except Exception as e:
        assert check_for_restart(e, _failed_before, opt_dir, log_fn)
        run_again = True
        pass
    if run_again:
        run_relax_opt(atoms, opt_dir, opter, get_calc_fn,
                      fmax=fmax, max_steps=max_steps, log_fn=log_fn, _failed_before=True)

def run_step(atoms, step_dir, fix_pair, get_calc_fn, opter,
             fmax=0.1, max_steps=50, log_fn=log_def, _failed_before=False):
    run_again = False
    add_bond_constraints(atoms, fix_pair, log_fn=log_fn)
    atoms.set_calculator(get_calc_fn(step_dir))
    try:
        run_opt_runner(atoms, step_dir, opter, log_fn=log_fn, fmax=fmax, max_steps=max_steps)
    except Exception as e:
        log_fn(e)
        assert check_for_restart(e, _failed_before, step_dir, log_fn)
        run_again = True
        pass
    if run_again:
        run_step(atoms, step_dir, fix_pair, get_calc_fn, opter,
                 fmax=fmax, max_steps=max_steps, log_fn=log_fn, _failed_before=True)


def setup_img_dirs(neb_dir, scan_dir, scan_steps, restart = False, log_fn=log_def):
    img_dirs = []
    for i in range(scan_steps):
        step_dir = opj(scan_dir, str(i))
        img_dir = opj(neb_dir, str(i))
        img_dirs.append(img_dir)
        restart = restart and ope(opj(img_dir, "POSCAR"))
        if not restart:
            if ope(img_dir):
                remove_dir_recursive(img_dir, log_fn=log_fn)
            os.mkdir(img_dir)
            copy_state_files(step_dir, img_dir, log_fn=log_fn)
            copy_file(opj(step_dir, "CONTCAR"), opj(img_dir, "POSCAR"), log_fn=log_fn)
    return img_dirs, restart

def setup_neb_imgs(front, img_dirs, pbc, get_calc_fn, log_fn=log_def, restart=False):
    imgs = []
    for i in range(front + 1):
        img_dir = img_dirs[i]
        log_fn(f"Looking for structure for image {i} in {img_dir}")
        img = get_atoms(img_dir, pbc, restart=restart)
        img.set_calculator(get_calc_fn(img_dirs[i]))
        imgs.append(img)
    return imgs


def setup_neb(scan_steps, k, neb_method, pbc, get_calc_fn, neb_dir, scan_dir,
              opter=FIRE, restart = False, use_ci = False, log_fn=log_def):
    restart = restart and ope(neb_dir + "hessian.pckl")
    img_dirs, restart = setup_img_dirs(neb_dir, scan_dir, scan_steps, restart=restart, log_fn=log_fn)
    imgs = setup_neb_imgs(scan_steps, img_dirs, pbc, get_calc_fn, restart=restart, log_fn=log_fn)
    neb = NEB(imgs, parallel=False, climb=use_ci, k=k, method=neb_method)
    dyn = neb_optimizer(neb, neb_dir, opter=opter)
    traj = Trajectory(opj(neb_dir, "neb.traj"), 'w', neb, properties=['energy', 'forces'])
    dyn.attach(traj)
    write_contcar = lambda img_dir, img: _write_contcar(img, img_dir)
    for i in range(scan_steps):
        dyn.attach(Trajectory(opj(img_dirs[i], 'opt-' + str(i) + '.traj'), 'w', imgs[i], properties=['energy', 'forces']))
        dyn.attach(write_contcar, interval=1, img_dir=img_dirs[i], image=imgs[i])
    return dyn

def setup_scan_dir(work_dir, scan_dir, relax_start_bool, restart_idx, pbc_bool_list, log_fn=log_def):
    dir0 = opj(scan_dir, "0")
    if not ope(scan_dir):
        os.mkdir(scan_dir)
    if not ope(dir0):
        os.mkdir(dir0)
        copy_state_files(work_dir, dir0)
        atoms = get_atoms(work_dir, pbc_bool_list, restart=True, log_fn=log_fn)
        write(opj(dir0, "POSCAR"), atoms, format="vasp")
    elif is_done(dir0, 0) and (not restart_idx==0):
        relax_start_bool = False
    log_fn("Checking for scan steps to be overwritten")
    int_dirs = get_int_dirs(work_dir)
    for dirr in int_dirs:
        idx = os.path.basename(dirr)
        if idx > restart_idx:
            log_fn(f"Step {idx} comes after requested restart index {restart_idx}")
            remove_dir_recursive(dirr)
    return relax_start_bool


if __name__ == '__main__':
    atom_pair, scan_steps, step_length, restart_idx, work_dir, follow, debug, max_steps, fmax, neb_method,\
        interp_method, k, neb_max_steps, pbc, relax_start, relax_end = read_se_neb_inputs()
    os.chdir(work_dir)
    scan_dir = opj(work_dir, "scan")
    restart_idx = get_restart_idx(restart_idx, scan_dir) # If was none, finds most recently converged step
    restart = restart_idx > 0
    skip_to_neb = (restart_idx > scan_steps)
    se_log = get_log_fn(work_dir, "se_neb", False, restart=restart)
    if restart_idx == 0:
        check_poscar(work_dir, se_log)
    ####################################################################################################################
    cmds = get_cmds(work_dir, ref_struct="POSCAR")
    if not debug:
        from JDFTx import JDFTx
        exe_cmd = get_exe_cmd(True, se_log)
        get_calc = lambda root: _get_calc(exe_cmd, cmds, root, JDFTx,
                                          debug=debug, log_fn=se_log)
    else:
        exe_cmd = " "
        from ase.calculators.emt import EMT as debug_calc
        get_calc = lambda root: _get_calc(exe_cmd, cmds, root, None,
                                          debug=debug, debug_fn=debug_calc, log_fn=se_log)
    ####################################################################################################################
    if not skip_to_neb:
        relax_start = setup_scan_dir(work_dir, scan_dir, relax_start, restart_idx, pbc, log_fn=se_log)
        do_relax_start(relax_start, scan_dir, get_calc, log_fn=se_log, fmax=fmax, max_steps=max_steps)
        start_length = get_start_dist(scan_dir, atom_pair, log_fn=se_log, restart=relax_start)
        prep_input = lambda i, step_dir_var: _prep_input(i, atom_pair, step_length, start_length, follow, step_dir_var,
                                                         scan_dir, step_type=1, log_func=se_log)
        for i in list(range(scan_steps))[restart_idx:]:
            if relax_start and (i == 0):
                continue
            step_dir = opj(scan_dir, str(i))
            restart_step = (i == restart_idx) and (not is_done(step_dir, i))
            if (not ope(step_dir)) or (not os.path.isdir(step_dir)):
                os.mkdir(step_dir)
            if i > 0 and not restart_step:
                prev_step_dir = opj(scan_dir, str(i-1))
                copy_state_files(prev_step_dir, step_dir, log_fn=se_log)
                prep_input(i, step_dir)
            atoms = get_atoms(step_dir, pbc, restart=restart_step, log_fn=se_log)
            run_step(atoms, step_dir, atom_pair, get_calc, FIRE,
                     fmax=fmax, max_steps=max_steps, log_fn=se_log)
        if relax_end:
            do_relax_end(scan_steps, scan_dir, restart_idx, pbc, get_calc,
                         log_fn=se_log, fmax=fmax, max_steps=max_steps)
    ####################################################################################################################
    neb_dir = opj(work_dir, "neb")
    if not ope(neb_dir):
        skip_to_neb = False
        os.mkdir(neb_dir)
    use_ci = has_max(get_fs(scan_dir)) # Use climbing image if PES have a local maximum
    dyn_neb = setup_neb(scan_steps + relax_end, k, neb_method, pbc, get_calc, neb_dir, scan_dir,
                        restart=skip_to_neb, use_ci=use_ci, log_fn=se_log)
    dyn_neb.run(fmax=fmax, steps=neb_max_steps)
    se_log(f"finished neb in {dyn_neb.nsteps}/{neb_max_steps} steps")
